# Copyright 2022 Gentoo Authors
# Distributed under the terms of the GNU General Public License v2

# @ECLASS: go.eclass
# @MAINTAINER:
# Ryan Qian <i@bitbili.net>
# @AUTHOR:
# Ryan Qian <i@bitbili.net>
# @SUPPORTED_EAPIS: 7 8
# @BLURB: basic eclass for building software written in golang
# @DESCRIPTION:
# This eclass provides basic settings and functions needed by software
# written in the go programming language.
#
# This eclass has three methods for offline building:
#
# ** priority: 1. > 2. > 3. **
#
# 1. for packages with the go.sum file which line number is less than GO_SUM_LIST_MAX (default to 100),
#    if the 'go.sum' file exists in the 'files' directory, this ebuild will automatically set the local
#    proxy url for all modules in the 'go.sum' file. You just need to add the GO_SUM_LIST_SRC_URI variable
#    into the SRC_URI variable.
#
# @CODE
#
# inherit go
#
# SRC_URI="https://github.com/example-org/reponame/archive/refs/tags/v${PV}.tar.gz -> ${P}.tar.gz"
# SRC_URI+=" ${GO_SUM_LIST_SRC_URI}"
#
# @CODE
#
# 2. use project embedded 'vendor' directory to build.
#    just inherit this eclass, don't need to do other special works
#
# @CODE
#
# inherit go
#
# @CODE
#
# 3. use extra 'vendor' directory to offer offline building, the vendor tarball can
#    be generated by the script https://github.com/bekcpear/vendor-for-go .
#    The tarball should consist of the directory architecture:
#    (name quoted by '[]' means optional)
#
#      [any-parent-directory/]
#
#          vendor/
#
#          [go-mod-sum.diff]   # should and expected to be empty if
#                              # the upstream did `go mod tidy` before releasing
#
# @CODE
#
# inherit go
#
# SRC_URI="https://github.com/example-org/reponame/archive/refs/tags/v${PV}.tar.gz -> ${P}.tar.gz
#  https://some.url/corresponding-vendor-path.tar.gz -> ${P}-vendor.tar.gz"
#
# @CODE
#
#
# #############################################################
# #############################################################
#
# Why use this eclass instead of the offical go-module.eclass, please refer to
# https://github.com/bekcpear/ryans-repos/issues/4
#
# Since Go programs are statically linked, it is important that your ebuild's
# LICENSE= setting includes the licenses of all modules.
# This script will be helpful to get the job done:
# https://github.com/bekcpear/go-licenses-for-gentoo
#
if [[ -z ${_ECLASS_GO} ]]; then
_ECLASS_GO=1

case ${EAPI} in
	7|8) ;;
	*) die "${ECLASS}: EAPI ${EAPI:-0} not supported" ;;
esac

BDEPEND=">=dev-lang/go-1.16"

EXPORT_FUNCTIONS src_unpack src_compile src_install

# @ECLASS_VARIABLE: GOFLAGS
# @DESCRIPTION:
# the default GOFLAGS.
# -buildvcs=false omits version control information
# -trimpath remove all file system paths from the resulting executable
# -v prints the names of packages as they are compiled
# -work prints the temporary work dir's name and don't delete it when exiting
# -x prints the commands
export GOFLAGS="-buildvcs=false -trimpath -v -work -x"

# @ECLASS_VARIABLE: EXTRA_GOFLAGS
# @DESCRIPTION:
# the extra GOFLAGS environment variable, default is empty,
# this value will be appended to the GOFLAGS if provided.
# Only valid when using the default src_compile of this eclass
# or 'go_build' function of this eclass.

# @ECLASS_VARIABLE: QA_FLAGS_IGNORED
# @INTERNAL
# @DESCRIPTION:
# ignore FLAGS due to go projects do not use them,
# this is a regex used by sed (without leading ^ and ending $).
QA_FLAGS_IGNORED='.*'

# Go packages should not be stripped with strip(1).
RESTRICT+=" strip"

# @ECLASS_VARIABLE: GO_LDFLAGS
# @DESCRIPTION:
# Flags pass to -ldflags, '-s' and '-w' flags will always be
# applied except calling go command directly.

# @ECLASS_VARIABLE: GO_SBIN
# @DESCRIPTION:
# names of binaries which should be installed as sbin

# @ECLASS_VARIABLE: GO_TAGS
# @DESCRIPTION:
# a comma-separated list of additional build tags to consider satisfied
# during the build
#
# @ECLASS_VARIABLE: GO_TARGET_PKGS
# @DESCRIPTION:
# a space-separated list of paths (relative to current work dir, normally $S)
# of packages which should be built instead of the default '.' or './cmd/...'

# @ECLASS_VARIABLE: GO_LDFLAGS_EXMAP
# @DESCRIPTION:
# Extra "variable name <-> output command" maps, the output command will be called
# and assign the standard output to the corresponding variable in src_compile phase.
# These variables will replace the corresponding formatted strings in GO_LDFLAGS.
# The formatted string should be like '@@VARIABLE-NAME@@'
# e.g.:
# 	GO_LDFLAGS_EXMAP[BUILD_DATE]="date '+%F %T%z'"
# 	GO_LDFLAGS="-X 'main.buildDate=@@BUILD_DATE@@'"
declare -A -g GO_LDFLAGS_EXMAP

# @ECLASS_VARIABLE: _GO_LDFLAGS_EXMAP_CACHE
# @INTERNAL
# @DESCRIPTION:
# cache for GO_LDFLAGS_EXMAP
declare -A -g _GO_LDFLAGS_EXMAP_CACHE

# @ECLASS_VARIABLE: GO_SUM_LIST_MAX
# @DESCRIPTION:
# The max line number of go.sum which can be used to set a local proxy,
# default to 100. This variable should be set before the eclass inherited.
: ${GO_SUM_LIST_MAX:=100}

# @ECLASS_VARIABLE: GO_SUM_LIST_SRC_URI
# @DESCRIPTION:
# SRC_URI for go.sum entiries
GO_SUM_LIST_SRC_URI=

# @ECLASS_VARIABLE: GO_SUM_LIST_SRC_URI_R
# @INTERNAL
# @DESCRIPTION:
# (internal variable) reversed map for GO_SUM_LIST_SRC_URI
declare -A -g GO_SUM_LIST_SRC_URI_R

# @FUNCTION: _go_escape_go_sum_path
# @DESCRIPTION:
# convert all capital letters in path to '!<lowercase>' format
_go_escape_go_sum_path() {
	local path="${1}" l
	while [[ "${path}" =~ (.*)([[:upper:]])(.*) ]]; do
		l=${BASH_REMATCH[2]@L}
		path="${BASH_REMATCH[1]}!${l}${BASH_REMATCH[3]}"
	done
	echo -n "${path}"
}

# @FUNCTION: _go_set_go_sum_list_src_uri
# @DESCRIPTION:
# set GO_SUM_LIST_SRC_URI
_go_set_go_sum_list_src_uri() {
	debug-print-function "${FUNCNAME}" "${@}"

	if [[ -n ${GO_SUM_LIST_SRC_URI} ]]; then
		return 0
	fi

	local _go_sum_list_file="${EBUILD%/*}/files/go.sum"
	if [[ ! -f "${_go_sum_list_file}" ]]; then
		return 0
	fi
	local -a _go_sum_list
	while read -r line; do
		_go_sum_list+=("${line}")
	done <"${_go_sum_list_file}"
	if [[ ${#_go_sum_list[@]} -gt ${GO_SUM_LIST_MAX} ]]; then
		return 0
	fi

	local _distfile_name _src_uri _ver _ext
	for line in "${_go_sum_list[@]}"; do
		<<<$(_go_escape_go_sum_path "${line}") read -r path ver _
		_ext=".zip"
		_ver=${ver%/go.mod}
		if [[ ${_ver} != ${ver} ]]; then
			_ext=".mod"
		fi
		path="${path}/@v/${_ver}${_ext}"
		_distfile_name="${path//\//%2F}"
		eval "GO_SUM_LIST_SRC_URI_R['${_distfile_name}']='${path}'"
		GO_SUM_LIST_SRC_URI+=" mirror://goproxy/${path} -> ${_distfile_name}"
	done

	export GOPROXY="file://${T}/go-proxy"
}
_go_set_go_sum_list_src_uri

# @FUNCTION: go_setup_proxy
# @DESCRIPTION:
# Setup the local proxy for downloading go modules.
go_setup_proxy() {
	debug-print-function "${FUNCNAME}" "${@}"

	local -a _default_A
	local _f _go_proxy_dir="${GOPROXY#file:\/\/}"

	mkdir -p ${_go_proxy_dir} || die

	for f in ${A}; do
		_f="${GO_SUM_LIST_SRC_URI_R[${f}]}"
		if [[ -n ${_f} ]]; then
			_f="${_go_proxy_dir}/${_f}"
			mkdir -p "$(dirname ${_f})" || die
			ln -sf ${DISTDIR}/${f} ${_f} || die
		else
			_default_A+=("${f}")
		fi
	done

	if [[ "$1" == "i" ]]; then
		declare -p _default_A
	fi
}

# @FUNCTION: go_setup_vendor
# @DESCRIPTION:
# setup vendor directory
go_setup_vendor() {
	debug-print-function "${FUNCNAME}" "${@}"

	if [[ ! -d "${S}/vendor" ]]; then
		local -a vendors
		local vendor go_mod_sum_diff
		vendors=($(find "${WORKDIR}" -maxdepth 2 -name 'vendor' 2>/dev/null || true))
		if [[ ${#vendors[@]} -gt 0 ]]; then
			vendor="${vendors[0]}"
			mv "${vendor}" "${S}" || die
			go_mod_sum_diff="$(dirname ${vendor})/go-mod-sum.diff"
			if [[ -s "${go_mod_sum_diff}" ]]; then
				pushd "${S}" >/dev/null || die
				eapply "${go_mod_sum_diff}"
				popd >/dev/null || die
			fi
		fi
	fi
}

# @FUNCTION: go_src_unpack
# @DESCRIPTION:
# src_unpack
go_src_unpack() {
	debug-print-function "${FUNCNAME}" "${@}"

	if [[ -n ${GO_SUM_LIST_SRC_URI} ]]; then
		# prepare local proxy
		eval "$(go_setup_proxy i)" || die
		for f in "${_default_A[@]}"; do
			unpack "${f}"
		done
	else
		# prepare vendor directory
		default
		go_setup_vendor
	fi
}

# @FUNCTION: go_build
# @USAGE: <packages>
# @DESCRIPTION:
# parse necessary arguments for go build and build packages,
# the binaries will be installed into the ${T}/go-bin/ directory.
go_build() {
	debug-print-function "${FUNCNAME}" "${@}"

	local go_ldflags="${GO_LDFLAGS}"

	[[ "${go_ldflags}" =~ (^|[[:space:]])-w([[:space:]]|$) ]] || go_ldflags="-w ${go_ldflags}"
	[[ "${go_ldflags}" =~ (^|[[:space:]])-s([[:space:]]|$) ]] || go_ldflags="-s ${go_ldflags}"

	local key value
	for key in "${!GO_LDFLAGS_EXMAP[@]}"; do
		if [[ -n "${_GO_LDFLAGS_EXMAP_CACHE[$key]}" ]]; then
			value="${_GO_LDFLAGS_EXMAP_CACHE[$key]}"
		else
			value=$(eval "${GO_LDFLAGS_EXMAP[$key]}" || true)
			if [[ -z ${value} ]]; then
				die "the stdout of command '$GO_LDFLAGS_EXMAP[$key]' (GO_LDFLAGS_EXMAP[$key]) is empty"
			fi
			_GO_LDFLAGS_EXMAP_CACHE[$key]=${value}
		fi
		go_ldflags=$(<<<"${go_ldflags}" sed "s/@@${key}@@/${value}/g")
	done

	GOFLAGS="${GOFLAGS}${EXTRA_GOFLAGS:+ }${EXTRA_GOFLAGS}"
	set -- go build -o "${T}/go-bin/" ${GO_TAGS:+-tags} ${GO_TAGS} -ldflags "${go_ldflags}" "${@}"
	einfo "      GOFLAGS:" "${GOFLAGS}"
	einfo "Build command:" "${@}"
	"${@}" || die
}

# @FUNCTION: go_src_compile
# @DESCRIPTION:
# src_compile
go_src_compile() {
	debug-print-function "${FUNCNAME}" "${@}"

	if [[ -d "cmd" ]] && [[ -z ${GO_TARGET_PKGS} ]] && \
		[[ $(find cmd/ -maxdepth 2 -type f -name '*.go' -exec \
			grep -E '^package[[:space:]]+main([[:space:]]|$)' '{}' \; 2>/dev/null || true) != "" ]]; then
		go_build ./cmd/...
	elif [[ -z ${GO_TARGET_PKGS} ]]; then
		go_build .
	else
		go_build ${GO_TARGET_PKGS}
	fi
}

# @FUNCTION: go_src_install
# @DESCRIPTION:
# src_install
go_src_install() {
	debug-print-function "${FUNCNAME}" "${@}"

	pushd "${T}"/go-bin >/dev/null || die

	local _sb _sbin
	if [[ $(declare -p GO_SBIN) =~ declare[[:space:]]+-a ]]; then
		_sbin="${GO_SBIN[*]}"
	else
		_sbin="${GO_SBIN}"
	fi
	for _sb in ${_sbin}; do
		if ls ${_sb} &>/dev/null; then
			dosbin ${_sb}
			rm -f ${_sb} || die
		fi
	done

	dobin *

	popd >/dev/null || die
}

fi
